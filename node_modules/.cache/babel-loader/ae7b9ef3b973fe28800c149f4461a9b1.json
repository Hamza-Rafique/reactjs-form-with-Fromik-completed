{"ast":null,"code":"import has from 'lodash/has'; // @ts-expect-error\n\nimport toposort from 'toposort';\nimport { split } from 'property-expr';\nimport Ref from '../Reference';\nimport isSchema from './isSchema';\nexport default function sortFields(fields) {\n  var excludes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var edges = [];\n  var nodes = [];\n\n  function addNode(depPath, key) {\n    var node = split(depPath)[0];\n    if (!~nodes.indexOf(node)) nodes.push(node);\n    if (!~excludes.indexOf(\"\".concat(key, \"-\").concat(node))) edges.push([key, node]);\n  }\n\n  var _loop = function _loop(key) {\n    if (has(fields, key)) {\n      var value = fields[key];\n      if (!~nodes.indexOf(key)) nodes.push(key);\n      if (Ref.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(function (path) {\n        return addNode(path, key);\n      });\n    }\n  };\n\n  for (var key in fields) {\n    _loop(key);\n  }\n\n  return toposort.array(nodes, edges).reverse();\n}","map":{"version":3,"sources":["/Users/fe-mac-hamza/Desktop/React-Form-with-Formik/node_modules/yup/es/util/sortFields.js"],"names":["has","toposort","split","Ref","isSchema","sortFields","fields","excludes","edges","nodes","addNode","depPath","key","node","indexOf","push","value","isRef","isSibling","path","deps","forEach","array","reverse"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,YAAhB,C,CAA8B;;AAE9B,OAAOC,QAAP,MAAqB,UAArB;AACA,SAASC,KAAT,QAAsB,eAAtB;AACA,OAAOC,GAAP,MAAgB,cAAhB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,eAAe,SAASC,UAAT,CAAoBC,MAApB,EAA2C;AAAA,MAAfC,QAAe,uEAAJ,EAAI;AACxD,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,KAAK,GAAG,EAAZ;;AAEA,WAASC,OAAT,CAAiBC,OAAjB,EAA0BC,GAA1B,EAA+B;AAC7B,QAAIC,IAAI,GAAGX,KAAK,CAACS,OAAD,CAAL,CAAe,CAAf,CAAX;AACA,QAAI,CAAC,CAACF,KAAK,CAACK,OAAN,CAAcD,IAAd,CAAN,EAA2BJ,KAAK,CAACM,IAAN,CAAWF,IAAX;AAC3B,QAAI,CAAC,CAACN,QAAQ,CAACO,OAAT,WAAoBF,GAApB,cAA2BC,IAA3B,EAAN,EAA0CL,KAAK,CAACO,IAAN,CAAW,CAACH,GAAD,EAAMC,IAAN,CAAX;AAC3C;;AARuD,6BAU7CD,GAV6C;AAU9B,QAAIZ,GAAG,CAACM,MAAD,EAASM,GAAT,CAAP,EAAsB;AAC9C,UAAII,KAAK,GAAGV,MAAM,CAACM,GAAD,CAAlB;AACA,UAAI,CAAC,CAACH,KAAK,CAACK,OAAN,CAAcF,GAAd,CAAN,EAA0BH,KAAK,CAACM,IAAN,CAAWH,GAAX;AAC1B,UAAIT,GAAG,CAACc,KAAJ,CAAUD,KAAV,KAAoBA,KAAK,CAACE,SAA9B,EAAyCR,OAAO,CAACM,KAAK,CAACG,IAAP,EAAaP,GAAb,CAAP,CAAzC,KAAuE,IAAIR,QAAQ,CAACY,KAAD,CAAR,IAAmB,UAAUA,KAAjC,EAAwCA,KAAK,CAACI,IAAN,CAAWC,OAAX,CAAmB,UAAAF,IAAI;AAAA,eAAIT,OAAO,CAACS,IAAD,EAAOP,GAAP,CAAX;AAAA,OAAvB;AAChH;AAduD;;AAUxD,OAAK,IAAMA,GAAX,IAAkBN,MAAlB;AAAA,UAAWM,GAAX;AAAA;;AAMA,SAAOX,QAAQ,CAACqB,KAAT,CAAeb,KAAf,EAAsBD,KAAtB,EAA6Be,OAA7B,EAAP;AACD","sourcesContent":["import has from 'lodash/has'; // @ts-expect-error\n\nimport toposort from 'toposort';\nimport { split } from 'property-expr';\nimport Ref from '../Reference';\nimport isSchema from './isSchema';\nexport default function sortFields(fields, excludes = []) {\n  let edges = [];\n  let nodes = [];\n\n  function addNode(depPath, key) {\n    var node = split(depPath)[0];\n    if (!~nodes.indexOf(node)) nodes.push(node);\n    if (!~excludes.indexOf(`${key}-${node}`)) edges.push([key, node]);\n  }\n\n  for (const key in fields) if (has(fields, key)) {\n    let value = fields[key];\n    if (!~nodes.indexOf(key)) nodes.push(key);\n    if (Ref.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));\n  }\n\n  return toposort.array(nodes, edges).reverse();\n}"]},"metadata":{},"sourceType":"module"}