{"ast":null,"code":"import _slicedToArray from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport has from 'lodash/has';\nimport _snakeCase from 'lodash/snakeCase';\nimport _camelCase from 'lodash/camelCase';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport { getter } from 'property-expr';\nimport { object as locale } from './locale';\nimport sortFields from './util/sortFields';\nimport sortByKeyOrder from './util/sortByKeyOrder';\nimport runTests from './util/runTests';\nimport ValidationError from './ValidationError';\nimport BaseSchema from './schema';\n\nvar isObject = function isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n};\n\nfunction unknown(ctx, value) {\n  var known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(function (key) {\n    return known.indexOf(key) === -1;\n  });\n}\n\nvar defaultSort = sortByKeyOrder([]);\n\nvar ObjectSchema = /*#__PURE__*/function (_BaseSchema) {\n  _inherits(ObjectSchema, _BaseSchema);\n\n  var _super = _createSuper(ObjectSchema);\n\n  function ObjectSchema(spec) {\n    var _this;\n\n    _classCallCheck(this, ObjectSchema);\n\n    _this = _super.call(this, {\n      type: 'object'\n    });\n    _this.fields = Object.create(null);\n    _this._sortErrors = defaultSort;\n    _this._nodes = [];\n    _this._excludedEdges = [];\n\n    _this.withMutation(function () {\n      _this.transform(function coerce(value) {\n        if (typeof value === 'string') {\n          try {\n            value = JSON.parse(value);\n          } catch (err) {\n            value = null;\n          }\n        }\n\n        if (this.isType(value)) return value;\n        return null;\n      });\n\n      if (spec) {\n        _this.shape(spec);\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(ObjectSchema, [{\n    key: \"_typeCheck\",\n    value: function _typeCheck(value) {\n      return isObject(value) || typeof value === 'function';\n    }\n  }, {\n    key: \"_cast\",\n    value: function _cast(_value) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _options$stripUnknown;\n\n      var value = _get(_getPrototypeOf(ObjectSchema.prototype), \"_cast\", this).call(this, _value, options); //should ignore nulls here\n\n\n      if (value === undefined) return this.getDefault();\n      if (!this._typeCheck(value)) return value;\n      var fields = this.fields;\n      var strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n\n      var props = this._nodes.concat(Object.keys(value).filter(function (v) {\n        return _this2._nodes.indexOf(v) === -1;\n      }));\n\n      var intermediateValue = {}; // is filled during the transform below\n\n      var innerOptions = _extends({}, options, {\n        parent: intermediateValue,\n        __validating: options.__validating || false\n      });\n\n      var isChanged = false;\n\n      var _iterator = _createForOfIteratorHelper(props),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n          var field = fields[prop];\n          var exists = has(value, prop);\n\n          if (field) {\n            var fieldValue = void 0;\n            var inputValue = value[prop]; // safe to mutate since this is fired in sequence\n\n            innerOptions.path = (options.path ? \"\".concat(options.path, \".\") : '') + prop; // innerOptions.value = value[prop];\n\n            field = field.resolve({\n              value: inputValue,\n              context: options.context,\n              parent: intermediateValue\n            });\n            var fieldSpec = 'spec' in field ? field.spec : undefined;\n            var strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n\n            if (fieldSpec == null ? void 0 : fieldSpec.strip) {\n              isChanged = isChanged || prop in value;\n              continue;\n            }\n\n            fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n            field.cast(value[prop], innerOptions) : value[prop];\n\n            if (fieldValue !== undefined) {\n              intermediateValue[prop] = fieldValue;\n            }\n          } else if (exists && !strip) {\n            intermediateValue[prop] = value[prop];\n          }\n\n          if (intermediateValue[prop] !== value[prop]) {\n            isChanged = true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return isChanged ? intermediateValue : value;\n    }\n  }, {\n    key: \"_validate\",\n    value: function _validate(_value) {\n      var _this3 = this;\n\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      var errors = [];\n      var sync = opts.sync,\n          _opts$from = opts.from,\n          from = _opts$from === void 0 ? [] : _opts$from,\n          _opts$originalValue = opts.originalValue,\n          originalValue = _opts$originalValue === void 0 ? _value : _opts$originalValue,\n          _opts$abortEarly = opts.abortEarly,\n          abortEarly = _opts$abortEarly === void 0 ? this.spec.abortEarly : _opts$abortEarly,\n          _opts$recursive = opts.recursive,\n          recursive = _opts$recursive === void 0 ? this.spec.recursive : _opts$recursive;\n      from = [{\n        schema: this,\n        value: originalValue\n      }].concat(_toConsumableArray(from)); // this flag is needed for handling `strict` correctly in the context of\n      // validation vs just casting. e.g strict() on a field is only used when validating\n\n      opts.__validating = true;\n      opts.originalValue = originalValue;\n      opts.from = from;\n\n      _get(_getPrototypeOf(ObjectSchema.prototype), \"_validate\", this).call(this, _value, opts, function (err, value) {\n        if (err) {\n          if (!ValidationError.isError(err) || abortEarly) {\n            return void callback(err, value);\n          }\n\n          errors.push(err);\n        }\n\n        if (!recursive || !isObject(value)) {\n          callback(errors[0] || null, value);\n          return;\n        }\n\n        originalValue = originalValue || value;\n\n        var tests = _this3._nodes.map(function (key) {\n          return function (_, cb) {\n            var path = key.indexOf('.') === -1 ? (opts.path ? \"\".concat(opts.path, \".\") : '') + key : \"\".concat(opts.path || '', \"[\\\"\").concat(key, \"\\\"]\");\n            var field = _this3.fields[key];\n\n            if (field && 'validate' in field) {\n              field.validate(value[key], _extends({}, opts, {\n                // @ts-ignore\n                path,\n                from,\n                // inner fields are always strict:\n                // 1. this isn't strict so the casting will also have cast inner values\n                // 2. this is strict in which case the nested values weren't cast either\n                strict: true,\n                parent: value,\n                originalValue: originalValue[key]\n              }), cb);\n              return;\n            }\n\n            cb(null);\n          };\n        });\n\n        runTests({\n          sync,\n          tests,\n          value,\n          errors,\n          endEarly: abortEarly,\n          sort: _this3._sortErrors,\n          path: opts.path\n        }, callback);\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(spec) {\n      var next = _get(_getPrototypeOf(ObjectSchema.prototype), \"clone\", this).call(this, spec);\n\n      next.fields = _extends({}, this.fields);\n      next._nodes = this._nodes;\n      next._excludedEdges = this._excludedEdges;\n      next._sortErrors = this._sortErrors;\n      return next;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(schema) {\n      var next = _get(_getPrototypeOf(ObjectSchema.prototype), \"concat\", this).call(this, schema);\n\n      var nextFields = next.fields;\n\n      for (var _i = 0, _Object$entries = Object.entries(this.fields); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            field = _Object$entries$_i[0],\n            schemaOrRef = _Object$entries$_i[1];\n\n        var target = nextFields[field];\n\n        if (target === undefined) {\n          nextFields[field] = schemaOrRef;\n        } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {\n          nextFields[field] = schemaOrRef.concat(target);\n        }\n      }\n\n      return next.withMutation(function (next) {\n        return next.shape(nextFields);\n      });\n    }\n  }, {\n    key: \"getDefaultFromShape\",\n    value: function getDefaultFromShape() {\n      var _this4 = this;\n\n      var dft = {};\n\n      this._nodes.forEach(function (key) {\n        var field = _this4.fields[key];\n        dft[key] = 'default' in field ? field.getDefault() : undefined;\n      });\n\n      return dft;\n    }\n  }, {\n    key: \"_getDefault\",\n    value: function _getDefault() {\n      if ('default' in this.spec) {\n        return _get(_getPrototypeOf(ObjectSchema.prototype), \"_getDefault\", this).call(this);\n      } // if there is no default set invent one\n\n\n      if (!this._nodes.length) {\n        return undefined;\n      }\n\n      return this.getDefaultFromShape();\n    }\n  }, {\n    key: \"shape\",\n    value: function shape(additions) {\n      var excludes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var next = this.clone();\n      var fields = Object.assign(next.fields, additions);\n      next.fields = fields;\n      next._sortErrors = sortByKeyOrder(Object.keys(fields));\n\n      if (excludes.length) {\n        if (!Array.isArray(excludes[0])) excludes = [excludes];\n        var keys = excludes.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              first = _ref2[0],\n              second = _ref2[1];\n\n          return \"\".concat(first, \"-\").concat(second);\n        });\n        next._excludedEdges = next._excludedEdges.concat(keys);\n      }\n\n      next._nodes = sortFields(fields, next._excludedEdges);\n      return next;\n    }\n  }, {\n    key: \"pick\",\n    value: function pick(keys) {\n      var picked = {};\n\n      var _iterator2 = _createForOfIteratorHelper(keys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          if (this.fields[key]) picked[key] = this.fields[key];\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return this.clone().withMutation(function (next) {\n        next.fields = {};\n        return next.shape(picked);\n      });\n    }\n  }, {\n    key: \"omit\",\n    value: function omit(keys) {\n      var next = this.clone();\n      var fields = next.fields;\n      next.fields = {};\n\n      var _iterator3 = _createForOfIteratorHelper(keys),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var key = _step3.value;\n          delete fields[key];\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return next.withMutation(function (next) {\n        return next.shape(fields);\n      });\n    }\n  }, {\n    key: \"from\",\n    value: function from(_from, to, alias) {\n      var fromGetter = getter(_from, true);\n      return this.transform(function (obj) {\n        if (obj == null) return obj;\n        var newObj = obj;\n\n        if (has(obj, _from)) {\n          newObj = _extends({}, obj);\n          if (!alias) delete newObj[_from];\n          newObj[to] = fromGetter(obj);\n        }\n\n        return newObj;\n      });\n    }\n  }, {\n    key: \"noUnknown\",\n    value: function noUnknown() {\n      var noAllow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.noUnknown;\n\n      if (typeof noAllow === 'string') {\n        message = noAllow;\n        noAllow = true;\n      }\n\n      var next = this.test({\n        name: 'noUnknown',\n        exclusive: true,\n        message: message,\n\n        test(value) {\n          if (value == null) return true;\n          var unknownKeys = unknown(this.schema, value);\n          return !noAllow || unknownKeys.length === 0 || this.createError({\n            params: {\n              unknown: unknownKeys.join(', ')\n            }\n          });\n        }\n\n      });\n      next.spec.noUnknown = noAllow;\n      return next;\n    }\n  }, {\n    key: \"unknown\",\n    value: function unknown() {\n      var allow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.noUnknown;\n      return this.noUnknown(!allow, message);\n    }\n  }, {\n    key: \"transformKeys\",\n    value: function transformKeys(fn) {\n      return this.transform(function (obj) {\n        return obj && mapKeys(obj, function (_, key) {\n          return fn(key);\n        });\n      });\n    }\n  }, {\n    key: \"camelCase\",\n    value: function camelCase() {\n      return this.transformKeys(_camelCase);\n    }\n  }, {\n    key: \"snakeCase\",\n    value: function snakeCase() {\n      return this.transformKeys(_snakeCase);\n    }\n  }, {\n    key: \"constantCase\",\n    value: function constantCase() {\n      return this.transformKeys(function (key) {\n        return _snakeCase(key).toUpperCase();\n      });\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var base = _get(_getPrototypeOf(ObjectSchema.prototype), \"describe\", this).call(this);\n\n      base.fields = mapValues(this.fields, function (value) {\n        return value.describe();\n      });\n      return base;\n    }\n  }]);\n\n  return ObjectSchema;\n}(BaseSchema);\n\nexport { ObjectSchema as default };\nexport function create(spec) {\n  return new ObjectSchema(spec);\n}\ncreate.prototype = ObjectSchema.prototype;","map":{"version":3,"sources":["/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/yup/es/object.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","has","snakeCase","camelCase","mapKeys","mapValues","getter","object","locale","sortFields","sortByKeyOrder","runTests","ValidationError","BaseSchema","isObject","obj","toString","unknown","ctx","value","known","keys","fields","filter","indexOf","defaultSort","ObjectSchema","spec","type","create","_sortErrors","_nodes","_excludedEdges","withMutation","transform","coerce","JSON","parse","err","isType","shape","_value","options","_options$stripUnknown","undefined","getDefault","_typeCheck","strip","stripUnknown","noUnknown","props","concat","v","intermediateValue","innerOptions","parent","__validating","isChanged","prop","field","exists","fieldValue","inputValue","path","resolve","context","fieldSpec","strict","cast","opts","callback","errors","sync","from","originalValue","abortEarly","recursive","schema","isError","push","tests","map","_","cb","validate","endEarly","sort","next","nextFields","entries","schemaOrRef","dft","forEach","getDefaultFromShape","additions","excludes","clone","Array","isArray","first","second","picked","to","alias","fromGetter","newObj","noAllow","message","test","name","exclusive","unknownKeys","createError","params","join","allow","fn","transformKeys","toUpperCase","base","describe"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport has from 'lodash/has';\nimport snakeCase from 'lodash/snakeCase';\nimport camelCase from 'lodash/camelCase';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport { getter } from 'property-expr';\nimport { object as locale } from './locale';\nimport sortFields from './util/sortFields';\nimport sortByKeyOrder from './util/sortByKeyOrder';\nimport runTests from './util/runTests';\nimport ValidationError from './ValidationError';\nimport BaseSchema from './schema';\n\nlet isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\n\nfunction unknown(ctx, value) {\n  let known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(key => known.indexOf(key) === -1);\n}\n\nconst defaultSort = sortByKeyOrder([]);\nexport default class ObjectSchema extends BaseSchema {\n  constructor(spec) {\n    super({\n      type: 'object'\n    });\n    this.fields = Object.create(null);\n    this._sortErrors = defaultSort;\n    this._nodes = [];\n    this._excludedEdges = [];\n    this.withMutation(() => {\n      this.transform(function coerce(value) {\n        if (typeof value === 'string') {\n          try {\n            value = JSON.parse(value);\n          } catch (err) {\n            value = null;\n          }\n        }\n\n        if (this.isType(value)) return value;\n        return null;\n      });\n\n      if (spec) {\n        this.shape(spec);\n      }\n    });\n  }\n\n  _typeCheck(value) {\n    return isObject(value) || typeof value === 'function';\n  }\n\n  _cast(_value, options = {}) {\n    var _options$stripUnknown;\n\n    let value = super._cast(_value, options); //should ignore nulls here\n\n\n    if (value === undefined) return this.getDefault();\n    if (!this._typeCheck(value)) return value;\n    let fields = this.fields;\n    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n\n    let props = this._nodes.concat(Object.keys(value).filter(v => this._nodes.indexOf(v) === -1));\n\n    let intermediateValue = {}; // is filled during the transform below\n\n    let innerOptions = _extends({}, options, {\n      parent: intermediateValue,\n      __validating: options.__validating || false\n    });\n\n    let isChanged = false;\n\n    for (const prop of props) {\n      let field = fields[prop];\n      let exists = has(value, prop);\n\n      if (field) {\n        let fieldValue;\n        let inputValue = value[prop]; // safe to mutate since this is fired in sequence\n\n        innerOptions.path = (options.path ? `${options.path}.` : '') + prop; // innerOptions.value = value[prop];\n\n        field = field.resolve({\n          value: inputValue,\n          context: options.context,\n          parent: intermediateValue\n        });\n        let fieldSpec = 'spec' in field ? field.spec : undefined;\n        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n\n        if (fieldSpec == null ? void 0 : fieldSpec.strip) {\n          isChanged = isChanged || prop in value;\n          continue;\n        }\n\n        fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n        field.cast(value[prop], innerOptions) : value[prop];\n\n        if (fieldValue !== undefined) {\n          intermediateValue[prop] = fieldValue;\n        }\n      } else if (exists && !strip) {\n        intermediateValue[prop] = value[prop];\n      }\n\n      if (intermediateValue[prop] !== value[prop]) {\n        isChanged = true;\n      }\n    }\n\n    return isChanged ? intermediateValue : value;\n  }\n\n  _validate(_value, opts = {}, callback) {\n    let errors = [];\n    let {\n      sync,\n      from = [],\n      originalValue = _value,\n      abortEarly = this.spec.abortEarly,\n      recursive = this.spec.recursive\n    } = opts;\n    from = [{\n      schema: this,\n      value: originalValue\n    }, ...from]; // this flag is needed for handling `strict` correctly in the context of\n    // validation vs just casting. e.g strict() on a field is only used when validating\n\n    opts.__validating = true;\n    opts.originalValue = originalValue;\n    opts.from = from;\n\n    super._validate(_value, opts, (err, value) => {\n      if (err) {\n        if (!ValidationError.isError(err) || abortEarly) {\n          return void callback(err, value);\n        }\n\n        errors.push(err);\n      }\n\n      if (!recursive || !isObject(value)) {\n        callback(errors[0] || null, value);\n        return;\n      }\n\n      originalValue = originalValue || value;\n\n      let tests = this._nodes.map(key => (_, cb) => {\n        let path = key.indexOf('.') === -1 ? (opts.path ? `${opts.path}.` : '') + key : `${opts.path || ''}[\"${key}\"]`;\n        let field = this.fields[key];\n\n        if (field && 'validate' in field) {\n          field.validate(value[key], _extends({}, opts, {\n            // @ts-ignore\n            path,\n            from,\n            // inner fields are always strict:\n            // 1. this isn't strict so the casting will also have cast inner values\n            // 2. this is strict in which case the nested values weren't cast either\n            strict: true,\n            parent: value,\n            originalValue: originalValue[key]\n          }), cb);\n          return;\n        }\n\n        cb(null);\n      });\n\n      runTests({\n        sync,\n        tests,\n        value,\n        errors,\n        endEarly: abortEarly,\n        sort: this._sortErrors,\n        path: opts.path\n      }, callback);\n    });\n  }\n\n  clone(spec) {\n    const next = super.clone(spec);\n    next.fields = _extends({}, this.fields);\n    next._nodes = this._nodes;\n    next._excludedEdges = this._excludedEdges;\n    next._sortErrors = this._sortErrors;\n    return next;\n  }\n\n  concat(schema) {\n    let next = super.concat(schema);\n    let nextFields = next.fields;\n\n    for (let [field, schemaOrRef] of Object.entries(this.fields)) {\n      const target = nextFields[field];\n\n      if (target === undefined) {\n        nextFields[field] = schemaOrRef;\n      } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {\n        nextFields[field] = schemaOrRef.concat(target);\n      }\n    }\n\n    return next.withMutation(next => next.shape(nextFields));\n  }\n\n  getDefaultFromShape() {\n    let dft = {};\n\n    this._nodes.forEach(key => {\n      const field = this.fields[key];\n      dft[key] = 'default' in field ? field.getDefault() : undefined;\n    });\n\n    return dft;\n  }\n\n  _getDefault() {\n    if ('default' in this.spec) {\n      return super._getDefault();\n    } // if there is no default set invent one\n\n\n    if (!this._nodes.length) {\n      return undefined;\n    }\n\n    return this.getDefaultFromShape();\n  }\n\n  shape(additions, excludes = []) {\n    let next = this.clone();\n    let fields = Object.assign(next.fields, additions);\n    next.fields = fields;\n    next._sortErrors = sortByKeyOrder(Object.keys(fields));\n\n    if (excludes.length) {\n      if (!Array.isArray(excludes[0])) excludes = [excludes];\n      let keys = excludes.map(([first, second]) => `${first}-${second}`);\n      next._excludedEdges = next._excludedEdges.concat(keys);\n    }\n\n    next._nodes = sortFields(fields, next._excludedEdges);\n    return next;\n  }\n\n  pick(keys) {\n    const picked = {};\n\n    for (const key of keys) {\n      if (this.fields[key]) picked[key] = this.fields[key];\n    }\n\n    return this.clone().withMutation(next => {\n      next.fields = {};\n      return next.shape(picked);\n    });\n  }\n\n  omit(keys) {\n    const next = this.clone();\n    const fields = next.fields;\n    next.fields = {};\n\n    for (const key of keys) {\n      delete fields[key];\n    }\n\n    return next.withMutation(next => next.shape(fields));\n  }\n\n  from(from, to, alias) {\n    let fromGetter = getter(from, true);\n    return this.transform(obj => {\n      if (obj == null) return obj;\n      let newObj = obj;\n\n      if (has(obj, from)) {\n        newObj = _extends({}, obj);\n        if (!alias) delete newObj[from];\n        newObj[to] = fromGetter(obj);\n      }\n\n      return newObj;\n    });\n  }\n\n  noUnknown(noAllow = true, message = locale.noUnknown) {\n    if (typeof noAllow === 'string') {\n      message = noAllow;\n      noAllow = true;\n    }\n\n    let next = this.test({\n      name: 'noUnknown',\n      exclusive: true,\n      message: message,\n\n      test(value) {\n        if (value == null) return true;\n        const unknownKeys = unknown(this.schema, value);\n        return !noAllow || unknownKeys.length === 0 || this.createError({\n          params: {\n            unknown: unknownKeys.join(', ')\n          }\n        });\n      }\n\n    });\n    next.spec.noUnknown = noAllow;\n    return next;\n  }\n\n  unknown(allow = true, message = locale.noUnknown) {\n    return this.noUnknown(!allow, message);\n  }\n\n  transformKeys(fn) {\n    return this.transform(obj => obj && mapKeys(obj, (_, key) => fn(key)));\n  }\n\n  camelCase() {\n    return this.transformKeys(camelCase);\n  }\n\n  snakeCase() {\n    return this.transformKeys(snakeCase);\n  }\n\n  constantCase() {\n    return this.transformKeys(key => snakeCase(key).toUpperCase());\n  }\n\n  describe() {\n    let base = super.describe();\n    base.fields = mapValues(this.fields, value => value.describe());\n    return base;\n  }\n\n}\nexport function create(spec) {\n  return new ObjectSchema(spec);\n}\ncreate.prototype = ObjectSchema.prototype;"]},"metadata":{},"sourceType":"module"}