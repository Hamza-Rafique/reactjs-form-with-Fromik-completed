{"ast":null,"code":"import _classCallCheck from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport has from 'lodash/has';\nimport isSchema from './util/isSchema';\n\nvar Condition = /*#__PURE__*/function () {\n  function Condition(refs, options) {\n    _classCallCheck(this, Condition);\n\n    this.refs = refs;\n    this.refs = refs;\n\n    if (typeof options === 'function') {\n      this.fn = options;\n      return;\n    }\n\n    if (!has(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    var is = options.is,\n        then = options.then,\n        otherwise = options.otherwise;\n    var check = typeof is === 'function' ? is : function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      return values.every(function (value) {\n        return value === is;\n      });\n    };\n\n    this.fn = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var options = args.pop();\n      var schema = args.pop();\n      var branch = check.apply(void 0, args) ? then : otherwise;\n      if (!branch) return undefined;\n      if (typeof branch === 'function') return branch(schema);\n      return schema.concat(branch.resolve(options));\n    };\n  }\n\n  _createClass(Condition, [{\n    key: \"resolve\",\n    value: function resolve(base, options) {\n      var values = this.refs.map(function (ref) {\n        return ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n      });\n      var schema = this.fn.apply(base, values.concat(base, options));\n      if (schema === undefined || schema === base) return base;\n      if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');\n      return schema.resolve(options);\n    }\n  }]);\n\n  return Condition;\n}();\n\nexport default Condition;","map":{"version":3,"sources":["/Users/fe-mac-hamza/Downloads/React-Form-with-Formik/node_modules/yup/es/Condition.js"],"names":["has","isSchema","Condition","refs","options","fn","TypeError","then","otherwise","is","check","values","every","value","args","pop","schema","branch","undefined","concat","resolve","base","map","ref","getValue","parent","context","apply"],"mappings":";;AAAA,OAAOA,GAAP,MAAgB,YAAhB;AACA,OAAOC,QAAP,MAAqB,iBAArB;;IAEMC,S;AACJ,qBAAYC,IAAZ,EAAkBC,OAAlB,EAA2B;AAAA;;AACzB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKA,IAAL,GAAYA,IAAZ;;AAEA,QAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC;AACjC,WAAKC,EAAL,GAAUD,OAAV;AACA;AACD;;AAED,QAAI,CAACJ,GAAG,CAACI,OAAD,EAAU,IAAV,CAAR,EAAyB,MAAM,IAAIE,SAAJ,CAAc,2CAAd,CAAN;AACzB,QAAI,CAACF,OAAO,CAACG,IAAT,IAAiB,CAACH,OAAO,CAACI,SAA9B,EAAyC,MAAM,IAAIF,SAAJ,CAAc,oEAAd,CAAN;AAVhB,QAYvBG,EAZuB,GAerBL,OAfqB,CAYvBK,EAZuB;AAAA,QAavBF,IAbuB,GAerBH,OAfqB,CAavBG,IAbuB;AAAA,QAcvBC,SAduB,GAerBJ,OAfqB,CAcvBI,SAduB;AAgBzB,QAAIE,KAAK,GAAG,OAAOD,EAAP,KAAc,UAAd,GAA2BA,EAA3B,GAAgC;AAAA,wCAAIE,MAAJ;AAAIA,QAAAA,MAAJ;AAAA;;AAAA,aAAeA,MAAM,CAACC,KAAP,CAAa,UAAAC,KAAK;AAAA,eAAIA,KAAK,KAAKJ,EAAd;AAAA,OAAlB,CAAf;AAAA,KAA5C;;AAEA,SAAKJ,EAAL,GAAU,YAAmB;AAAA,yCAANS,IAAM;AAANA,QAAAA,IAAM;AAAA;;AAC3B,UAAIV,OAAO,GAAGU,IAAI,CAACC,GAAL,EAAd;AACA,UAAIC,MAAM,GAAGF,IAAI,CAACC,GAAL,EAAb;AACA,UAAIE,MAAM,GAAGP,KAAK,MAAL,SAASI,IAAT,IAAiBP,IAAjB,GAAwBC,SAArC;AACA,UAAI,CAACS,MAAL,EAAa,OAAOC,SAAP;AACb,UAAI,OAAOD,MAAP,KAAkB,UAAtB,EAAkC,OAAOA,MAAM,CAACD,MAAD,CAAb;AAClC,aAAOA,MAAM,CAACG,MAAP,CAAcF,MAAM,CAACG,OAAP,CAAehB,OAAf,CAAd,CAAP;AACD,KAPD;AAQD;;;;4BAEOiB,I,EAAMjB,O,EAAS;AACrB,UAAIO,MAAM,GAAG,KAAKR,IAAL,CAAUmB,GAAV,CAAc,UAAAC,GAAG;AAAA,eAAIA,GAAG,CAACC,QAAJ,CAAapB,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACS,KAAhD,EAAuDT,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACqB,MAA1F,EAAkGrB,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACsB,OAArI,CAAJ;AAAA,OAAjB,CAAb;AACA,UAAIV,MAAM,GAAG,KAAKX,EAAL,CAAQsB,KAAR,CAAcN,IAAd,EAAoBV,MAAM,CAACQ,MAAP,CAAcE,IAAd,EAAoBjB,OAApB,CAApB,CAAb;AACA,UAAIY,MAAM,KAAKE,SAAX,IAAwBF,MAAM,KAAKK,IAAvC,EAA6C,OAAOA,IAAP;AAC7C,UAAI,CAACpB,QAAQ,CAACe,MAAD,CAAb,EAAuB,MAAM,IAAIV,SAAJ,CAAc,wCAAd,CAAN;AACvB,aAAOU,MAAM,CAACI,OAAP,CAAehB,OAAf,CAAP;AACD;;;;;;AAIH,eAAeF,SAAf","sourcesContent":["import has from 'lodash/has';\nimport isSchema from './util/isSchema';\n\nclass Condition {\n  constructor(refs, options) {\n    this.refs = refs;\n    this.refs = refs;\n\n    if (typeof options === 'function') {\n      this.fn = options;\n      return;\n    }\n\n    if (!has(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    let {\n      is,\n      then,\n      otherwise\n    } = options;\n    let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);\n\n    this.fn = function (...args) {\n      let options = args.pop();\n      let schema = args.pop();\n      let branch = check(...args) ? then : otherwise;\n      if (!branch) return undefined;\n      if (typeof branch === 'function') return branch(schema);\n      return schema.concat(branch.resolve(options));\n    };\n  }\n\n  resolve(base, options) {\n    let values = this.refs.map(ref => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));\n    let schema = this.fn.apply(base, values.concat(base, options));\n    if (schema === undefined || schema === base) return base;\n    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');\n    return schema.resolve(options);\n  }\n\n}\n\nexport default Condition;"]},"metadata":{},"sourceType":"module"}