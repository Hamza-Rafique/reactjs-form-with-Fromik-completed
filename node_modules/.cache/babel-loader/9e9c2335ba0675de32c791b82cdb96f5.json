{"ast":null,"code":"import _toConsumableArray from \"/Users/fe-mac-hamza/Desktop/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/fe-mac-hamza/Desktop/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/fe-mac-hamza/Desktop/React-Form-with-Formik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // @ts-ignore\n\n\nimport cloneDeep from 'nanoclone';\nimport { mixed as locale } from './locale';\nimport Condition from './Condition';\nimport runTests from './util/runTests';\nimport createValidation from './util/createValidation';\nimport printValue from './util/printValue';\nimport Ref from './Reference';\nimport { getIn } from './util/reach';\nimport toArray from './util/toArray';\nimport { ValidationError } from '.';\nimport ReferenceSet from './util/ReferenceSet';\n\nvar BaseSchema = /*#__PURE__*/function () {\n  function BaseSchema(options) {\n    var _this = this;\n\n    _classCallCheck(this, BaseSchema);\n\n    this.deps = [];\n    this.conditions = [];\n    this._whitelist = new ReferenceSet();\n    this._blacklist = new ReferenceSet();\n    this.exclusiveTests = Object.create(null);\n    this.tests = [];\n    this.transforms = [];\n    this.withMutation(function () {\n      _this.typeError(locale.notType);\n    });\n    this.type = (options == null ? void 0 : options.type) || 'mixed';\n    this.spec = _extends({\n      strip: false,\n      strict: false,\n      abortEarly: true,\n      recursive: true,\n      label: undefined,\n      meta: undefined,\n      nullable: false,\n      presence: 'optional'\n    }, options == null ? void 0 : options.spec);\n  } // TODO: remove\n\n\n  _createClass(BaseSchema, [{\n    key: \"_typeCheck\",\n    value: function _typeCheck(_value) {\n      return true;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(spec) {\n      if (this._mutate) {\n        if (spec) Object.assign(this.spec, spec);\n        return this;\n      } // if the nested value is a schema we can skip cloning, since\n      // they are already immutable\n\n\n      var next = Object.create(Object.getPrototypeOf(this)); // @ts-expect-error this is readonly\n\n      next.type = this.type;\n      next._typeError = this._typeError;\n      next._whitelistError = this._whitelistError;\n      next._blacklistError = this._blacklistError;\n      next._whitelist = this._whitelist.clone();\n      next._blacklist = this._blacklist.clone();\n      next.exclusiveTests = _extends({}, this.exclusiveTests); // @ts-expect-error this is readonly\n\n      next.deps = _toConsumableArray(this.deps);\n      next.conditions = _toConsumableArray(this.conditions);\n      next.tests = _toConsumableArray(this.tests);\n      next.transforms = _toConsumableArray(this.transforms);\n      next.spec = cloneDeep(_extends({}, this.spec, spec));\n      return next;\n    }\n  }, {\n    key: \"label\",\n    value: function label(_label) {\n      var next = this.clone();\n      next.spec.label = _label;\n      return next;\n    }\n  }, {\n    key: \"meta\",\n    value: function meta() {\n      if (arguments.length === 0) return this.spec.meta;\n      var next = this.clone();\n      next.spec.meta = Object.assign(next.spec.meta || {}, arguments.length <= 0 ? undefined : arguments[0]);\n      return next;\n    } // withContext<TContext extends AnyObject>(): BaseSchema<\n    //   TCast,\n    //   TContext,\n    //   TOutput\n    // > {\n    //   return this as any;\n    // }\n\n  }, {\n    key: \"withMutation\",\n    value: function withMutation(fn) {\n      var before = this._mutate;\n      this._mutate = true;\n      var result = fn(this);\n      this._mutate = before;\n      return result;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(schema) {\n      if (!schema || schema === this) return this;\n      if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(\"You cannot `concat()` schema's of different types: \".concat(this.type, \" and \").concat(schema.type));\n      var base = this;\n      var combined = schema.clone();\n\n      var mergedSpec = _extends({}, base.spec, combined.spec); // if (combined.spec.nullable === UNSET)\n      //   mergedSpec.nullable = base.spec.nullable;\n      // if (combined.spec.presence === UNSET)\n      //   mergedSpec.presence = base.spec.presence;\n\n\n      combined.spec = mergedSpec;\n      combined._typeError || (combined._typeError = base._typeError);\n      combined._whitelistError || (combined._whitelistError = base._whitelistError);\n      combined._blacklistError || (combined._blacklistError = base._blacklistError); // manually merge the blacklist/whitelist (the other `schema` takes\n      // precedence in case of conflicts)\n\n      combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n      combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist); // start with the current tests\n\n      combined.tests = base.tests;\n      combined.exclusiveTests = base.exclusiveTests; // manually add the new tests to ensure\n      // the deduping logic is consistent\n\n      combined.withMutation(function (next) {\n        schema.tests.forEach(function (fn) {\n          next.test(fn.OPTIONS);\n        });\n      });\n      return combined;\n    }\n  }, {\n    key: \"isType\",\n    value: function isType(v) {\n      if (this.spec.nullable && v === null) return true;\n      return this._typeCheck(v);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(options) {\n      var schema = this;\n\n      if (schema.conditions.length) {\n        var conditions = schema.conditions;\n        schema = schema.clone();\n        schema.conditions = [];\n        schema = conditions.reduce(function (schema, condition) {\n          return condition.resolve(schema, options);\n        }, schema);\n        schema = schema.resolve(options);\n      }\n\n      return schema;\n    }\n    /**\n     *\n     * @param {*} value\n     * @param {Object} options\n     * @param {*=} options.parent\n     * @param {*=} options.context\n     */\n\n  }, {\n    key: \"cast\",\n    value: function cast(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var resolvedSchema = this.resolve(_extends({\n        value\n      }, options));\n\n      var result = resolvedSchema._cast(value, options);\n\n      if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {\n        var formattedValue = printValue(value);\n        var formattedResult = printValue(result);\n        throw new TypeError(\"The value of \".concat(options.path || 'field', \" could not be cast to a value \") + \"that satisfies the schema type: \\\"\".concat(resolvedSchema._type, \"\\\". \\n\\n\") + \"attempted value: \".concat(formattedValue, \" \\n\") + (formattedResult !== formattedValue ? \"result of cast: \".concat(formattedResult) : ''));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_cast\",\n    value: function _cast(rawValue, _options) {\n      var _this2 = this;\n\n      var value = rawValue === undefined ? rawValue : this.transforms.reduce(function (value, fn) {\n        return fn.call(_this2, value, rawValue, _this2);\n      }, rawValue);\n\n      if (value === undefined) {\n        value = this.getDefault();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_validate\",\n    value: function _validate(_value) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cb = arguments.length > 2 ? arguments[2] : undefined;\n      var sync = options.sync,\n          path = options.path,\n          _options$from = options.from,\n          from = _options$from === void 0 ? [] : _options$from,\n          _options$originalValu = options.originalValue,\n          originalValue = _options$originalValu === void 0 ? _value : _options$originalValu,\n          _options$strict = options.strict,\n          strict = _options$strict === void 0 ? this.spec.strict : _options$strict,\n          _options$abortEarly = options.abortEarly,\n          abortEarly = _options$abortEarly === void 0 ? this.spec.abortEarly : _options$abortEarly;\n      var value = _value;\n\n      if (!strict) {\n        // this._validating = true;\n        value = this._cast(value, _extends({\n          assert: false\n        }, options)); // this._validating = false;\n      } // value is cast, we can check if it meets type requirements\n\n\n      var args = {\n        value,\n        path,\n        options,\n        originalValue,\n        schema: this,\n        label: this.spec.label,\n        sync,\n        from\n      };\n      var initialTests = [];\n      if (this._typeError) initialTests.push(this._typeError);\n      if (this._whitelistError) initialTests.push(this._whitelistError);\n      if (this._blacklistError) initialTests.push(this._blacklistError);\n      runTests({\n        args,\n        value,\n        path,\n        sync,\n        tests: initialTests,\n        endEarly: abortEarly\n      }, function (err) {\n        if (err) return void cb(err, value);\n        runTests({\n          tests: _this3.tests,\n          args,\n          path,\n          sync,\n          value,\n          endEarly: abortEarly\n        }, cb);\n      });\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value, options, maybeCb) {\n      var schema = this.resolve(_extends({}, options, {\n        value\n      })); // callback case is for nested validations\n\n      return typeof maybeCb === 'function' ? schema._validate(value, options, maybeCb) : new Promise(function (resolve, reject) {\n        return schema._validate(value, options, function (err, value) {\n          if (err) reject(err);else resolve(value);\n        });\n      });\n    }\n  }, {\n    key: \"validateSync\",\n    value: function validateSync(value, options) {\n      var schema = this.resolve(_extends({}, options, {\n        value\n      }));\n      var result;\n\n      schema._validate(value, _extends({}, options, {\n        sync: true\n      }), function (err, value) {\n        if (err) throw err;\n        result = value;\n      });\n\n      return result;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(value, options) {\n      return this.validate(value, options).then(function () {\n        return true;\n      }, function (err) {\n        if (ValidationError.isError(err)) return false;\n        throw err;\n      });\n    }\n  }, {\n    key: \"isValidSync\",\n    value: function isValidSync(value, options) {\n      try {\n        this.validateSync(value, options);\n        return true;\n      } catch (err) {\n        if (ValidationError.isError(err)) return false;\n        throw err;\n      }\n    }\n  }, {\n    key: \"_getDefault\",\n    value: function _getDefault() {\n      var defaultValue = this.spec.default;\n\n      if (defaultValue == null) {\n        return defaultValue;\n      }\n\n      return typeof defaultValue === 'function' ? defaultValue.call(this) : cloneDeep(defaultValue);\n    }\n  }, {\n    key: \"getDefault\",\n    value: function getDefault(options) {\n      var schema = this.resolve(options || {});\n      return schema._getDefault();\n    }\n  }, {\n    key: \"default\",\n    value: function _default(def) {\n      if (arguments.length === 0) {\n        return this._getDefault();\n      }\n\n      var next = this.clone({\n        default: def\n      });\n      return next;\n    }\n  }, {\n    key: \"strict\",\n    value: function strict() {\n      var isStrict = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var next = this.clone();\n      next.spec.strict = isStrict;\n      return next;\n    }\n  }, {\n    key: \"_isPresent\",\n    value: function _isPresent(value) {\n      return value != null;\n    }\n  }, {\n    key: \"defined\",\n    value: function defined() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : locale.defined;\n      return this.test({\n        message,\n        name: 'defined',\n        exclusive: true,\n\n        test(value) {\n          return value !== undefined;\n        }\n\n      });\n    }\n  }, {\n    key: \"required\",\n    value: function required() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : locale.required;\n      return this.clone({\n        presence: 'required'\n      }).withMutation(function (s) {\n        return s.test({\n          message,\n          name: 'required',\n          exclusive: true,\n\n          test(value) {\n            return this.schema._isPresent(value);\n          }\n\n        });\n      });\n    }\n  }, {\n    key: \"notRequired\",\n    value: function notRequired() {\n      var next = this.clone({\n        presence: 'optional'\n      });\n      next.tests = next.tests.filter(function (test) {\n        return test.OPTIONS.name !== 'required';\n      });\n      return next;\n    }\n  }, {\n    key: \"nullable\",\n    value: function nullable() {\n      var isNullable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var next = this.clone({\n        nullable: isNullable !== false\n      });\n      return next;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(fn) {\n      var next = this.clone();\n      next.transforms.push(fn);\n      return next;\n    }\n    /**\n     * Adds a test function to the schema's queue of tests.\n     * tests can be exclusive or non-exclusive.\n     *\n     * - exclusive tests, will replace any existing tests of the same name.\n     * - non-exclusive: can be stacked\n     *\n     * If a non-exclusive test is added to a schema with an exclusive test of the same name\n     * the exclusive test is removed and further tests of the same name will be stacked.\n     *\n     * If an exclusive test is added to a schema with non-exclusive tests of the same name\n     * the previous tests are removed and further tests of the same name will replace each other.\n     */\n\n  }, {\n    key: \"test\",\n    value: function test() {\n      var opts;\n\n      if (arguments.length === 1) {\n        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {\n          opts = {\n            test: arguments.length <= 0 ? undefined : arguments[0]\n          };\n        } else {\n          opts = arguments.length <= 0 ? undefined : arguments[0];\n        }\n      } else if (arguments.length === 2) {\n        opts = {\n          name: arguments.length <= 0 ? undefined : arguments[0],\n          test: arguments.length <= 1 ? undefined : arguments[1]\n        };\n      } else {\n        opts = {\n          name: arguments.length <= 0 ? undefined : arguments[0],\n          message: arguments.length <= 1 ? undefined : arguments[1],\n          test: arguments.length <= 2 ? undefined : arguments[2]\n        };\n      }\n\n      if (opts.message === undefined) opts.message = locale.default;\n      if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');\n      var next = this.clone();\n      var validate = createValidation(opts);\n      var isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n\n      if (opts.exclusive) {\n        if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');\n      }\n\n      if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n      next.tests = next.tests.filter(function (fn) {\n        if (fn.OPTIONS.name === opts.name) {\n          if (isExclusive) return false;\n          if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n        }\n\n        return true;\n      });\n      next.tests.push(validate);\n      return next;\n    }\n  }, {\n    key: \"when\",\n    value: function when(keys, options) {\n      if (!Array.isArray(keys) && typeof keys !== 'string') {\n        options = keys;\n        keys = '.';\n      }\n\n      var next = this.clone();\n      var deps = toArray(keys).map(function (key) {\n        return new Ref(key);\n      });\n      deps.forEach(function (dep) {\n        // @ts-ignore\n        if (dep.isSibling) next.deps.push(dep.key);\n      });\n      next.conditions.push(new Condition(deps, options));\n      return next;\n    }\n  }, {\n    key: \"typeError\",\n    value: function typeError(message) {\n      var next = this.clone();\n      next._typeError = createValidation({\n        message,\n        name: 'typeError',\n\n        test(value) {\n          if (value !== undefined && !this.schema.isType(value)) return this.createError({\n            params: {\n              type: this.schema._type\n            }\n          });\n          return true;\n        }\n\n      });\n      return next;\n    }\n  }, {\n    key: \"oneOf\",\n    value: function oneOf(enums) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.oneOf;\n      var next = this.clone();\n      enums.forEach(function (val) {\n        next._whitelist.add(val);\n\n        next._blacklist.delete(val);\n      });\n      next._whitelistError = createValidation({\n        message,\n        name: 'oneOf',\n\n        test(value) {\n          if (value === undefined) return true;\n          var valids = this.schema._whitelist;\n          return valids.has(value, this.resolve) ? true : this.createError({\n            params: {\n              values: valids.toArray().join(', ')\n            }\n          });\n        }\n\n      });\n      return next;\n    }\n  }, {\n    key: \"notOneOf\",\n    value: function notOneOf(enums) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.notOneOf;\n      var next = this.clone();\n      enums.forEach(function (val) {\n        next._blacklist.add(val);\n\n        next._whitelist.delete(val);\n      });\n      next._blacklistError = createValidation({\n        message,\n        name: 'notOneOf',\n\n        test(value) {\n          var invalids = this.schema._blacklist;\n          if (invalids.has(value, this.resolve)) return this.createError({\n            params: {\n              values: invalids.toArray().join(', ')\n            }\n          });\n          return true;\n        }\n\n      });\n      return next;\n    }\n  }, {\n    key: \"strip\",\n    value: function strip() {\n      var _strip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var next = this.clone();\n      next.spec.strip = _strip;\n      return next;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var next = this.clone();\n      var _next$spec = next.spec,\n          label = _next$spec.label,\n          meta = _next$spec.meta;\n      var description = {\n        meta,\n        label,\n        type: next.type,\n        oneOf: next._whitelist.describe(),\n        notOneOf: next._blacklist.describe(),\n        tests: next.tests.map(function (fn) {\n          return {\n            name: fn.OPTIONS.name,\n            params: fn.OPTIONS.params\n          };\n        }).filter(function (n, idx, list) {\n          return list.findIndex(function (c) {\n            return c.name === n.name;\n          }) === idx;\n        })\n      };\n      return description;\n    }\n  }, {\n    key: \"_type\",\n    get: function get() {\n      return this.type;\n    }\n  }]);\n\n  return BaseSchema;\n}(); // @ts-expect-error\n\n\nexport { BaseSchema as default };\nBaseSchema.prototype.__isYupSchema__ = true;\n\nvar _loop = function _loop() {\n  var method = _arr[_i];\n\n  BaseSchema.prototype[\"\".concat(method, \"At\")] = function (path, value) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _getIn = getIn(this, path, value, options.context),\n        parent = _getIn.parent,\n        parentPath = _getIn.parentPath,\n        schema = _getIn.schema;\n\n    return schema[method](parent && parent[parentPath], _extends({}, options, {\n      parent,\n      path\n    }));\n  };\n};\n\nfor (var _i = 0, _arr = ['validate', 'validateSync']; _i < _arr.length; _i++) {\n  _loop();\n}\n\nfor (var _i2 = 0, _arr2 = ['equals', 'is']; _i2 < _arr2.length; _i2++) {\n  var alias = _arr2[_i2];\n  BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;\n}\n\nfor (var _i3 = 0, _arr3 = ['not', 'nope']; _i3 < _arr3.length; _i3++) {\n  var _alias = _arr3[_i3];\n  BaseSchema.prototype[_alias] = BaseSchema.prototype.notOneOf;\n}\n\nBaseSchema.prototype.optional = BaseSchema.prototype.notRequired;","map":{"version":3,"sources":["/Users/fe-mac-hamza/Desktop/React-Form-with-Formik/node_modules/yup/es/schema.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","cloneDeep","mixed","locale","Condition","runTests","createValidation","printValue","Ref","getIn","toArray","ValidationError","ReferenceSet","BaseSchema","options","deps","conditions","_whitelist","_blacklist","exclusiveTests","create","tests","transforms","withMutation","typeError","notType","type","spec","strip","strict","abortEarly","recursive","label","undefined","meta","nullable","presence","_value","_mutate","next","getPrototypeOf","_typeError","_whitelistError","_blacklistError","clone","fn","before","result","schema","TypeError","base","combined","mergedSpec","merge","forEach","test","OPTIONS","v","_typeCheck","reduce","condition","resolve","value","resolvedSchema","_cast","assert","isType","formattedValue","formattedResult","path","_type","rawValue","_options","getDefault","cb","sync","from","originalValue","args","initialTests","push","endEarly","err","maybeCb","_validate","Promise","reject","validate","then","isError","validateSync","defaultValue","default","_getDefault","def","isStrict","message","defined","name","exclusive","required","s","_isPresent","filter","isNullable","opts","isExclusive","keys","Array","isArray","map","dep","isSibling","createError","params","enums","oneOf","val","add","delete","valids","has","values","join","notOneOf","invalids","description","describe","n","idx","list","findIndex","c","__isYupSchema__","method","context","parent","parentPath","alias","optional","notRequired"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// @ts-ignore\nimport cloneDeep from 'nanoclone';\nimport { mixed as locale } from './locale';\nimport Condition from './Condition';\nimport runTests from './util/runTests';\nimport createValidation from './util/createValidation';\nimport printValue from './util/printValue';\nimport Ref from './Reference';\nimport { getIn } from './util/reach';\nimport toArray from './util/toArray';\nimport { ValidationError } from '.';\nimport ReferenceSet from './util/ReferenceSet';\nexport default class BaseSchema {\n  constructor(options) {\n    this.deps = [];\n    this.conditions = [];\n    this._whitelist = new ReferenceSet();\n    this._blacklist = new ReferenceSet();\n    this.exclusiveTests = Object.create(null);\n    this.tests = [];\n    this.transforms = [];\n    this.withMutation(() => {\n      this.typeError(locale.notType);\n    });\n    this.type = (options == null ? void 0 : options.type) || 'mixed';\n    this.spec = _extends({\n      strip: false,\n      strict: false,\n      abortEarly: true,\n      recursive: true,\n      label: undefined,\n      meta: undefined,\n      nullable: false,\n      presence: 'optional'\n    }, options == null ? void 0 : options.spec);\n  } // TODO: remove\n\n\n  get _type() {\n    return this.type;\n  }\n\n  _typeCheck(_value) {\n    return true;\n  }\n\n  clone(spec) {\n    if (this._mutate) {\n      if (spec) Object.assign(this.spec, spec);\n      return this;\n    } // if the nested value is a schema we can skip cloning, since\n    // they are already immutable\n\n\n    const next = Object.create(Object.getPrototypeOf(this)); // @ts-expect-error this is readonly\n\n    next.type = this.type;\n    next._typeError = this._typeError;\n    next._whitelistError = this._whitelistError;\n    next._blacklistError = this._blacklistError;\n    next._whitelist = this._whitelist.clone();\n    next._blacklist = this._blacklist.clone();\n    next.exclusiveTests = _extends({}, this.exclusiveTests); // @ts-expect-error this is readonly\n\n    next.deps = [...this.deps];\n    next.conditions = [...this.conditions];\n    next.tests = [...this.tests];\n    next.transforms = [...this.transforms];\n    next.spec = cloneDeep(_extends({}, this.spec, spec));\n    return next;\n  }\n\n  label(label) {\n    var next = this.clone();\n    next.spec.label = label;\n    return next;\n  }\n\n  meta(...args) {\n    if (args.length === 0) return this.spec.meta;\n    let next = this.clone();\n    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n    return next;\n  } // withContext<TContext extends AnyObject>(): BaseSchema<\n  //   TCast,\n  //   TContext,\n  //   TOutput\n  // > {\n  //   return this as any;\n  // }\n\n\n  withMutation(fn) {\n    let before = this._mutate;\n    this._mutate = true;\n    let result = fn(this);\n    this._mutate = before;\n    return result;\n  }\n\n  concat(schema) {\n    if (!schema || schema === this) return this;\n    if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \\`concat()\\` schema's of different types: ${this.type} and ${schema.type}`);\n    let base = this;\n    let combined = schema.clone();\n\n    const mergedSpec = _extends({}, base.spec, combined.spec); // if (combined.spec.nullable === UNSET)\n    //   mergedSpec.nullable = base.spec.nullable;\n    // if (combined.spec.presence === UNSET)\n    //   mergedSpec.presence = base.spec.presence;\n\n\n    combined.spec = mergedSpec;\n    combined._typeError || (combined._typeError = base._typeError);\n    combined._whitelistError || (combined._whitelistError = base._whitelistError);\n    combined._blacklistError || (combined._blacklistError = base._blacklistError); // manually merge the blacklist/whitelist (the other `schema` takes\n    // precedence in case of conflicts)\n\n    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist); // start with the current tests\n\n    combined.tests = base.tests;\n    combined.exclusiveTests = base.exclusiveTests; // manually add the new tests to ensure\n    // the deduping logic is consistent\n\n    combined.withMutation(next => {\n      schema.tests.forEach(fn => {\n        next.test(fn.OPTIONS);\n      });\n    });\n    return combined;\n  }\n\n  isType(v) {\n    if (this.spec.nullable && v === null) return true;\n    return this._typeCheck(v);\n  }\n\n  resolve(options) {\n    let schema = this;\n\n    if (schema.conditions.length) {\n      let conditions = schema.conditions;\n      schema = schema.clone();\n      schema.conditions = [];\n      schema = conditions.reduce((schema, condition) => condition.resolve(schema, options), schema);\n      schema = schema.resolve(options);\n    }\n\n    return schema;\n  }\n  /**\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @param {*=} options.parent\n   * @param {*=} options.context\n   */\n\n\n  cast(value, options = {}) {\n    let resolvedSchema = this.resolve(_extends({\n      value\n    }, options));\n\n    let result = resolvedSchema._cast(value, options);\n\n    if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {\n      let formattedValue = printValue(value);\n      let formattedResult = printValue(result);\n      throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: \"${resolvedSchema._type}\". \\n\\n` + `attempted value: ${formattedValue} \\n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));\n    }\n\n    return result;\n  }\n\n  _cast(rawValue, _options) {\n    let value = rawValue === undefined ? rawValue : this.transforms.reduce((value, fn) => fn.call(this, value, rawValue, this), rawValue);\n\n    if (value === undefined) {\n      value = this.getDefault();\n    }\n\n    return value;\n  }\n\n  _validate(_value, options = {}, cb) {\n    let {\n      sync,\n      path,\n      from = [],\n      originalValue = _value,\n      strict = this.spec.strict,\n      abortEarly = this.spec.abortEarly\n    } = options;\n    let value = _value;\n\n    if (!strict) {\n      // this._validating = true;\n      value = this._cast(value, _extends({\n        assert: false\n      }, options)); // this._validating = false;\n    } // value is cast, we can check if it meets type requirements\n\n\n    let args = {\n      value,\n      path,\n      options,\n      originalValue,\n      schema: this,\n      label: this.spec.label,\n      sync,\n      from\n    };\n    let initialTests = [];\n    if (this._typeError) initialTests.push(this._typeError);\n    if (this._whitelistError) initialTests.push(this._whitelistError);\n    if (this._blacklistError) initialTests.push(this._blacklistError);\n    runTests({\n      args,\n      value,\n      path,\n      sync,\n      tests: initialTests,\n      endEarly: abortEarly\n    }, err => {\n      if (err) return void cb(err, value);\n      runTests({\n        tests: this.tests,\n        args,\n        path,\n        sync,\n        value,\n        endEarly: abortEarly\n      }, cb);\n    });\n  }\n\n  validate(value, options, maybeCb) {\n    let schema = this.resolve(_extends({}, options, {\n      value\n    })); // callback case is for nested validations\n\n    return typeof maybeCb === 'function' ? schema._validate(value, options, maybeCb) : new Promise((resolve, reject) => schema._validate(value, options, (err, value) => {\n      if (err) reject(err);else resolve(value);\n    }));\n  }\n\n  validateSync(value, options) {\n    let schema = this.resolve(_extends({}, options, {\n      value\n    }));\n    let result;\n\n    schema._validate(value, _extends({}, options, {\n      sync: true\n    }), (err, value) => {\n      if (err) throw err;\n      result = value;\n    });\n\n    return result;\n  }\n\n  isValid(value, options) {\n    return this.validate(value, options).then(() => true, err => {\n      if (ValidationError.isError(err)) return false;\n      throw err;\n    });\n  }\n\n  isValidSync(value, options) {\n    try {\n      this.validateSync(value, options);\n      return true;\n    } catch (err) {\n      if (ValidationError.isError(err)) return false;\n      throw err;\n    }\n  }\n\n  _getDefault() {\n    let defaultValue = this.spec.default;\n\n    if (defaultValue == null) {\n      return defaultValue;\n    }\n\n    return typeof defaultValue === 'function' ? defaultValue.call(this) : cloneDeep(defaultValue);\n  }\n\n  getDefault(options) {\n    let schema = this.resolve(options || {});\n    return schema._getDefault();\n  }\n\n  default(def) {\n    if (arguments.length === 0) {\n      return this._getDefault();\n    }\n\n    let next = this.clone({\n      default: def\n    });\n    return next;\n  }\n\n  strict(isStrict = true) {\n    var next = this.clone();\n    next.spec.strict = isStrict;\n    return next;\n  }\n\n  _isPresent(value) {\n    return value != null;\n  }\n\n  defined(message = locale.defined) {\n    return this.test({\n      message,\n      name: 'defined',\n      exclusive: true,\n\n      test(value) {\n        return value !== undefined;\n      }\n\n    });\n  }\n\n  required(message = locale.required) {\n    return this.clone({\n      presence: 'required'\n    }).withMutation(s => s.test({\n      message,\n      name: 'required',\n      exclusive: true,\n\n      test(value) {\n        return this.schema._isPresent(value);\n      }\n\n    }));\n  }\n\n  notRequired() {\n    var next = this.clone({\n      presence: 'optional'\n    });\n    next.tests = next.tests.filter(test => test.OPTIONS.name !== 'required');\n    return next;\n  }\n\n  nullable(isNullable = true) {\n    var next = this.clone({\n      nullable: isNullable !== false\n    });\n    return next;\n  }\n\n  transform(fn) {\n    var next = this.clone();\n    next.transforms.push(fn);\n    return next;\n  }\n  /**\n   * Adds a test function to the schema's queue of tests.\n   * tests can be exclusive or non-exclusive.\n   *\n   * - exclusive tests, will replace any existing tests of the same name.\n   * - non-exclusive: can be stacked\n   *\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\n   * the exclusive test is removed and further tests of the same name will be stacked.\n   *\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\n   * the previous tests are removed and further tests of the same name will replace each other.\n   */\n\n\n  test(...args) {\n    let opts;\n\n    if (args.length === 1) {\n      if (typeof args[0] === 'function') {\n        opts = {\n          test: args[0]\n        };\n      } else {\n        opts = args[0];\n      }\n    } else if (args.length === 2) {\n      opts = {\n        name: args[0],\n        test: args[1]\n      };\n    } else {\n      opts = {\n        name: args[0],\n        message: args[1],\n        test: args[2]\n      };\n    }\n\n    if (opts.message === undefined) opts.message = locale.default;\n    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');\n    let next = this.clone();\n    let validate = createValidation(opts);\n    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n\n    if (opts.exclusive) {\n      if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');\n    }\n\n    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n    next.tests = next.tests.filter(fn => {\n      if (fn.OPTIONS.name === opts.name) {\n        if (isExclusive) return false;\n        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n      }\n\n      return true;\n    });\n    next.tests.push(validate);\n    return next;\n  }\n\n  when(keys, options) {\n    if (!Array.isArray(keys) && typeof keys !== 'string') {\n      options = keys;\n      keys = '.';\n    }\n\n    let next = this.clone();\n    let deps = toArray(keys).map(key => new Ref(key));\n    deps.forEach(dep => {\n      // @ts-ignore\n      if (dep.isSibling) next.deps.push(dep.key);\n    });\n    next.conditions.push(new Condition(deps, options));\n    return next;\n  }\n\n  typeError(message) {\n    var next = this.clone();\n    next._typeError = createValidation({\n      message,\n      name: 'typeError',\n\n      test(value) {\n        if (value !== undefined && !this.schema.isType(value)) return this.createError({\n          params: {\n            type: this.schema._type\n          }\n        });\n        return true;\n      }\n\n    });\n    return next;\n  }\n\n  oneOf(enums, message = locale.oneOf) {\n    var next = this.clone();\n    enums.forEach(val => {\n      next._whitelist.add(val);\n\n      next._blacklist.delete(val);\n    });\n    next._whitelistError = createValidation({\n      message,\n      name: 'oneOf',\n\n      test(value) {\n        if (value === undefined) return true;\n        let valids = this.schema._whitelist;\n        return valids.has(value, this.resolve) ? true : this.createError({\n          params: {\n            values: valids.toArray().join(', ')\n          }\n        });\n      }\n\n    });\n    return next;\n  }\n\n  notOneOf(enums, message = locale.notOneOf) {\n    var next = this.clone();\n    enums.forEach(val => {\n      next._blacklist.add(val);\n\n      next._whitelist.delete(val);\n    });\n    next._blacklistError = createValidation({\n      message,\n      name: 'notOneOf',\n\n      test(value) {\n        let invalids = this.schema._blacklist;\n        if (invalids.has(value, this.resolve)) return this.createError({\n          params: {\n            values: invalids.toArray().join(', ')\n          }\n        });\n        return true;\n      }\n\n    });\n    return next;\n  }\n\n  strip(strip = true) {\n    let next = this.clone();\n    next.spec.strip = strip;\n    return next;\n  }\n\n  describe() {\n    const next = this.clone();\n    const {\n      label,\n      meta\n    } = next.spec;\n    const description = {\n      meta,\n      label,\n      type: next.type,\n      oneOf: next._whitelist.describe(),\n      notOneOf: next._blacklist.describe(),\n      tests: next.tests.map(fn => ({\n        name: fn.OPTIONS.name,\n        params: fn.OPTIONS.params\n      })).filter((n, idx, list) => list.findIndex(c => c.name === n.name) === idx)\n    };\n    return description;\n  }\n\n}\n// @ts-expect-error\nBaseSchema.prototype.__isYupSchema__ = true;\n\nfor (const method of ['validate', 'validateSync']) BaseSchema.prototype[`${method}At`] = function (path, value, options = {}) {\n  const {\n    parent,\n    parentPath,\n    schema\n  } = getIn(this, path, value, options.context);\n  return schema[method](parent && parent[parentPath], _extends({}, options, {\n    parent,\n    path\n  }));\n};\n\nfor (const alias of ['equals', 'is']) BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;\n\nfor (const alias of ['not', 'nope']) BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;\n\nBaseSchema.prototype.optional = BaseSchema.prototype.notRequired;"]},"metadata":{},"sourceType":"module"}